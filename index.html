<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPC Debugger</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: rgb(227, 226, 226);
            color: white;
            margin: 0;
            padding: 0;
            display: flex;
            min-height: 100vh;
        }
        .left-panel {
            width: 30%;
            padding: 20px;
            background: #2a2a3a;
            border-right: 1px solid #444;
            overflow-y: auto;
        }
        .right-panel {
            width: 70%;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        .top-right {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .table-container, .ipc-visualization-container {
            flex: 1;
            background: #2a2a3a;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        .log-container {
            flex: 1;
            background: #2a2a3a;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            overflow-y: auto;
            max-height: 300px;
        }
        h1, h2, h3 {
            color: #fff;
            margin-top: 0;
        }
        button {
            padding: 8px 16px;
            margin: 5px;
            font-size: 14px;
            cursor: pointer;
            border: none;
            background-color: #007bff;
            color: white;
            border-radius: 5px;
            transition: 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        #force-deadlock {
            background-color: #ff5722;
        }
        #force-deadlock:hover {
            background-color: #e64a19;
        }
        #resolve-deadlock {
            background-color: #dc3545;
        }
        #resolve-deadlock:hover {
            background-color: #c82333;
        }
        select, input {
            padding: 8px;
            border-radius: 5px;
            border: none;
            margin: 5px;
            background: #3a3a5a;
            color: white;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 5px;
        }
        .status-running {
            background-color: #28a745;
        }
        .status-blocked {
            background-color: #dc3545;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
            font-size: 14px;
        }
        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #444;
        }
        th {
            background-color: #3a3a5a;
        }
        .safe-sequence {
            background-color: #2d3748;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border-left: 4px solid #48bb78;
        }
        .sequence-step {
            display: inline-block;
            margin: 0 5px;
            padding: 5px 10px;
            background-color: #4299e1;
            border-radius: 4px;
        }
        .deadlock-reason {
            color: #ff6b6b;
            margin: 10px 0;
            font-size: 14px;
        }
        .ipc-visual {
            margin: 5px 0;
            padding: 8px;
            background: #3a3a5a;
            border-radius: 5px;
            font-family: monospace;
        }
        .statistics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }
        .stat-item {
            background: #2d3748;
            padding: 8px;
            border-radius: 5px;
            font-size: 14px;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 10px 0;
        }
        .control-group {
            margin-bottom: 15px;
            padding: 10px;
            background: #2d3748;
            border-radius: 8px;
        }
        .radio-group {
            margin: 10px 0;
        }
        .radio-group label {
            display: block;
            margin: 5px 0;
            cursor: pointer;
        }
        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #444;
            font-size: 14px;
        }
        #deadlock-status {
            font-weight: bold;
            margin: 10px 0;
        }
        
        /* IPC Visualization Styles */
        #visualization-area {
            position: relative;
            height: 300px;
            border: 2px solid #444;
            border-radius: 5px;
            background: #1e1e2f;
            overflow: hidden;
        }
        .process-visual {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            background: #4299e1;
            color: white;
            z-index: 10;
        }
        .resource-visual {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            background: #48bb78;
            color: white;
            z-index: 10;
        }
        .ipc-channel {
            position: absolute;
            height: 3px;
            background: white;
            transform-origin: 0 0;
            z-index: 5;
        }
        .ipc-label {
            position: absolute;
            color: white;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 5px;
            border-radius: 3px;
            z-index: 20;
        }
        #ipc-method-label {
            background: #3a3a5a;
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="left-panel">
        <h1>IPC Debugger</h1>
        
        <div class="control-group">
            <h3>System Setup</h3>
            <div class="controls">
                <div>
                    <label for="num-processes">Processes:</label>
                    <input type="number" id="num-processes" value="3" min="2" max="5">
                </div>
                <div>
                    <label for="num-resources">Resources:</label>
                    <input type="number" id="num-resources" value="3" min="2" max="5">
                </div>
            </div>
            <button onclick="setupSystem()">Initialize</button>
            <button id="force-deadlock" onclick="forceDeadlock()">Force Deadlock</button>
        </div>

        <div class="control-group">
            <h3>IPC Control</h3>
            <div class="controls">
                <select id="ipc-method">
                    <option value="pipe">Pipe</option>
                    <option value="queue">Message Queue</option>
                    <option value="shm">Shared Memory</option>
                </select>
                <button onclick="startExchange()">Start Exchange</button>
                <button onclick="stopExchange()" style="background-color:#dc3545;">Stop</button>
            </div>
        </div>

        <div class="control-group">
            <h3>Deadlock Detection</h3>
            <div class="radio-group">
                <label><input type="radio" name="detection-method" value="rag" checked> Resource Allocation Graph</label>
                <label><input type="radio" name="detection-method" value="wait-for"> Wait-For Graph</label>
                <label><input type="radio" name="detection-method" value="banker"> Banker's Algorithm</label>
                <label><input type="radio" name="detection-method" value="random"> Random Detection</label>
            </div>
        </div>

        <div class="control-group">
            <h3>Deadlock Recovery</h3>
            <div class="radio-group">
                <label><input type="radio" name="recovery-method" value="termination" checked> Process Termination</label>
                <label><input type="radio" name="recovery-method" value="preemption"> Resource Preemption</label>
            </div>
            <button id="resolve-deadlock" onclick="resolveDeadlock()">Resolve Deadlock</button>
        </div>

        <div class="statistics">
            <div class="stat-item">
                <div>Exchanges: <span id="exchange-count">0</span></div>
            </div>
            <div class="stat-item">
                <div>Deadlocks: <span id="deadlock-count">0</span></div>
            </div>
            <div class="stat-item">
                <div>Blocked: <span id="blocked-count">0</span></div>
            </div>
            <div class="stat-item">
                <div>Resources Used: <span id="resource-usage">0%</span></div>
            </div>
        </div>

        <div id="deadlock-status">System ready</div>
        <div id="deadlock-reason" class="deadlock-reason"></div>

        <div id="safe-sequence-container" class="safe-sequence" style="display:none;">
            <h3>Safe Execution Sequence</h3>
            <div id="safe-sequence"></div>
        </div>
    </div>

    <div class="right-panel">
        <div class="top-right">
            <div class="table-container">
                <h2>Process Table</h2>
                <div id="process-table"></div>
            </div>
            <div class="table-container">
                <h2>Resource Allocation</h2>
                <div id="resource-table"></div>
            </div>
        </div>

        <div class="ipc-visualization-container">
            <div class="flex justify-between items-center mb-4">
                <h2>IPC Visualization</h2>
                <div id="ipc-method-label" class="px-3 py-1 rounded-full text-sm">
                    Pipes
                </div>
            </div>
            <div id="visualization-area">
                <div class="absolute inset-0 flex items-center justify-center text-gray-400">
                    Initialize system to start visualization
                </div>
            </div>
        </div>

        <div class="log-container">
            <h2>System Log</h2>
            <div id="log-container"></div>
        </div>

        <div class="log-container">
            <h2>IPC Log</h2>
            <div id="exchange-log"></div>
        </div>
    </div>

    <script>
        let processes = [];
        let resources = [];
        let exchangeInterval;
        let deadlockCheckInterval;
        let deadlockDetected = false;
        let exchangeCount = 0;
        let deadlockCount = 0;
        const MAX_EXCHANGES = 15;
        let activeChannels = [];
        
        function setupSystem() {
            stopExchange();
            
            const numProcesses = parseInt(document.getElementById("num-processes").value);
            const numResources = parseInt(document.getElementById("num-resources").value);
            
            resources = [];
            for (let i = 0; i < numResources; i++) {
                resources.push({
                    id: `R${i}`,
                    holder: null,
                    total: 1,
                    available: 1
                });
            }
            
            processes = [];
            for (let i = 0; i < numProcesses; i++) {
                processes.push({
                    id: `P${i}`,
                    holding: [],
                    waiting: null,
                    status: 'running',
                    needed: Math.floor(Math.random() * 2) + 1,
                    max: Math.floor(Math.random() * 2) + 2
                });
                
                if (Math.random() > 0.3) {
                    const availableResources = resources.filter(r => r.available > 0);
                    if (availableResources.length > 0) {
                        const resource = availableResources[Math.floor(Math.random() * availableResources.length)];
                        resource.holder = `P${i}`;
                        resource.available--;
                        processes[i].holding.push(resource.id);
                    }
                }
            }
            
            updateProcessTable();
            updateResourceTable();
            updateVisualization();
            updateStatistics();
            logMessage(`System initialized with ${numProcesses} processes and ${numResources} resources`);
            document.getElementById("resolve-deadlock").style.display = "none";
            document.getElementById("deadlock-reason").textContent = "";
            document.getElementById("safe-sequence-container").style.display = "none";
            document.getElementById("deadlock-status").textContent = "System ready";
            exchangeCount = 0;
            deadlockDetected = false;
        }
        
        function forceDeadlock() {
            if (processes.length < 2 || resources.length < 2) {
                logMessage("Need at least 2 processes and 2 resources to force deadlock");
                return;
            }
            
            // Clear any existing allocations
            resources.forEach(r => {
                r.holder = null;
                r.available = r.total;
            });
            processes.forEach(p => {
                p.holding = [];
                p.waiting = null;
                p.status = 'running';
            });
            
            // Create circular wait condition
            resources[0].holder = "P0";
            resources[0].available = 0;
            processes[0].holding = ["R0"];
            processes[0].waiting = "R1";
            processes[0].status = "blocked";
            
            resources[1].holder = "P1";
            resources[1].available = 0;
            processes[1].holding = ["R1"];
            processes[1].waiting = "R0";
            processes[1].status = "blocked";
            
            // Set needed values
            processes[0].needed = 2;
            processes[1].needed = 2;
            
            updateProcessTable();
            updateResourceTable();
            updateVisualization();
            updateStatistics();
            logMessage("FORCED DEADLOCK: P0→R1→P1→R0→P0");
            document.getElementById("deadlock-status").innerHTML = 
                '<span style="color:#dc3545">DEADLOCK CREATED - Click Start Exchange to detect</span>';
        }
        
        function startExchange() {
            if (exchangeInterval) clearInterval(exchangeInterval);
            if (deadlockCheckInterval) clearInterval(deadlockCheckInterval);
            
            exchangeCount = 0;
            deadlockDetected = false;
            
            // Update IPC method label
            const method = document.getElementById("ipc-method").value;
            const methodLabel = document.getElementById("ipc-method-label");
            methodLabel.textContent = 
                method === 'pipe' ? 'Pipes' : 
                method === 'queue' ? 'Message Queue' : 'Shared Memory';
            
            exchangeInterval = setInterval(() => {
                if (processes.length < 2) {
                    logMessage("Need at least 2 processes");
                    stopExchange();
                    return;
                }
                
                if (exchangeCount++ >= MAX_EXCHANGES) {
                    logMessage(`Stopping after ${MAX_EXCHANGES} exchanges`);
                    stopExchange();
                    return;
                }
                
                updateStatistics();
                
                const processIndex = Math.floor(Math.random() * processes.length);
                const process = processes[processIndex];
                
                if (Math.random() < 0.6 && process.holding.length < process.needed) {
                    const availableResources = resources.filter(r => !process.holding.includes(r.id) && r.available > 0);
                    if (availableResources.length > 0) {
                        const resource = availableResources[Math.floor(Math.random() * availableResources.length)];
                        
                        if (resource.holder && resource.holder !== process.id) {
                            process.waiting = resource.id;
                            process.status = 'blocked';
                            logMessage(`${process.id} blocked waiting for ${resource.id} (held by ${resource.holder})`);
                            logExchange(`${getIPCMethodVisualization()} ${process.id} → ${resource.holder} BLOCKED (waiting for ${resource.id})`);
                            
                            // Visualize the IPC request
                            visualizeIPC(process.id, resource.holder, resource.id, 'request');
                        } else if (!resource.holder) {
                            resource.holder = process.id;
                            resource.available--;
                            process.holding.push(resource.id);
                            logMessage(`${process.id} acquired ${resource.id}`);
                            logExchange(`${getIPCMethodVisualization()} ${process.id} acquired ${resource.id}`);
                            
                            // Visualize the resource acquisition
                            visualizeIPC(process.id, null, resource.id, 'acquire');
                        }
                    }
                }
                
                if (Math.random() < 0.3 && process.holding.length > 0) {
                    const resourceId = process.holding[Math.floor(Math.random() * process.holding.length)];
                    const resource = resources.find(r => r.id === resourceId);
                    if (resource) {
                        resource.holder = null;
                        resource.available++;
                        process.holding = process.holding.filter(id => id !== resourceId);
                        logMessage(`${process.id} released ${resourceId}`);
                        logExchange(`${getIPCMethodVisualization()} ${process.id} released ${resourceId}`);
                        
                        // Visualize the resource release
                        visualizeIPC(process.id, null, resourceId, 'release');
                        
                        processes.forEach(p => {
                            if (p.waiting === resourceId) {
                                p.waiting = null;
                                p.status = 'running';
                                logMessage(`${p.id} no longer waiting for ${resourceId}`);
                                
                                // Visualize the resource transfer
                                visualizeIPC(process.id, p.id, resourceId, 'transfer');
                            }
                        });
                    }
                }
                
                updateProcessTable();
                updateResourceTable();
                updateVisualization();
                updateStatistics();
            }, 800);
            
            deadlockCheckInterval = setInterval(checkDeadlock, 1000);
            
            logMessage("Started data exchange");
            document.getElementById("deadlock-status").textContent = "Exchange running";
        }
        
        function stopExchange() {
            if (exchangeInterval) {
                clearInterval(exchangeInterval);
                exchangeInterval = null;
            }
            if (deadlockCheckInterval) {
                clearInterval(deadlockCheckInterval);
                deadlockCheckInterval = null;
            }
            
            // Clear all active channels
            activeChannels = [];
            updateVisualization();
            
            logMessage("Stopped data exchange");
            document.getElementById("deadlock-status").textContent = "Exchange stopped";
            calculateSafeSequence();
            updateStatistics();
        }
        
        function visualizeIPC(from, to, resource, action) {
            // Clear previous channels
            const visualizationArea = document.getElementById("visualization-area");
            
            // Add new channel
            if (action === 'request' && from && to) {
                const channelId = `channel-${from}-${to}-${Date.now()}`;
                activeChannels.push({
                    id: channelId,
                    from,
                    to,
                    resource,
                    action
                });
                
                // Update visualization immediately
                updateVisualization();
                
                // Remove after animation
                setTimeout(() => {
                    activeChannels = activeChannels.filter(c => c.id !== channelId);
                    updateVisualization();
                }, 700);
            } else if (action === 'acquire' || action === 'release') {
                // Just update the visualization to show resource changes
                updateVisualization();
            }
        }
        
        function updateVisualization() {
            const visualizationArea = document.getElementById("visualization-area");
            visualizationArea.innerHTML = '';
            
            if (processes.length === 0 || resources.length === 0) {
                visualizationArea.innerHTML = '<div class="absolute inset-0 flex items-center justify-center text-gray-400">Initialize system to start visualization</div>';
                return;
            }
            
            // Position processes in a circle
            const centerX = visualizationArea.clientWidth / 2;
            const centerY = visualizationArea.clientHeight / 2;
            const radius = Math.min(centerX, centerY) * 0.8;
            
            // Create process visual elements
            processes.forEach((process, i) => {
                const angle = (i / processes.length) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle) - 30;
                const y = centerY + radius * Math.sin(angle) - 30;
                
                const processElement = document.createElement('div');
                processElement.className = `process-visual ${process.status === 'blocked' ? 'bg-red-500' : 'bg-blue-500'}`;
                processElement.textContent = process.id;
                processElement.style.left = `${x}px`;
                processElement.style.top = `${y}px`;
                processElement.style.backgroundColor = process.status === 'blocked' ? '#dc3545' : '#4299e1';
                visualizationArea.appendChild(processElement);
                
                // Show waiting status
                if (process.waiting) {
                    const waitingText = document.createElement('div');
                    waitingText.className = 'ipc-label';
                    waitingText.textContent = `Waiting for ${process.waiting}`;
                    waitingText.style.left = `${x + 70}px`;
                    waitingText.style.top = `${y + 20}px`;
                    visualizationArea.appendChild(waitingText);
                }
            });
            
            // Create resource visual elements (inner circle)
            resources.forEach((resource, i) => {
                const angle = (i / resources.length) * 2 * Math.PI;
                const x = centerX + (radius * 0.6) * Math.cos(angle) - 25;
                const y = centerY + (radius * 0.6) * Math.sin(angle) - 25;
                
                const resourceElement = document.createElement('div');
                resourceElement.className = 'resource-visual';
                resourceElement.textContent = resource.id;
                resourceElement.style.left = `${x}px`;
                resourceElement.style.top = `${y}px`;
                resourceElement.style.backgroundColor = resource.holder ? '#48bb78' : '#6b7280';
                visualizationArea.appendChild(resourceElement);
                
                // Show holder if any
                if (resource.holder) {
                    const holderText = document.createElement('div');
                    holderText.className = 'ipc-label';
                    holderText.textContent = `Held by ${resource.holder}`;
                    holderText.style.left = `${x - 30}px`;
                    holderText.style.top = `${y - 30}px`;
                    visualizationArea.appendChild(holderText);
                }
            });
            
            // Draw active IPC channels
            activeChannels.forEach(channel => {
                const fromProcess = document.querySelector(`.process-visual:contains('${channel.from}')`);
                const toProcess = document.querySelector(`.process-visual:contains('${channel.to}')`);
                
                if (fromProcess && toProcess) {
                    const fromRect = fromProcess.getBoundingClientRect();
                    const toRect = toProcess.getBoundingClientRect();
                    const areaRect = visualizationArea.getBoundingClientRect();
                    
                    const fromX = fromRect.left + fromRect.width/2 - areaRect.left;
                    const fromY = fromRect.top + fromRect.height/2 - areaRect.top;
                    const toX = toRect.left + toRect.width/2 - areaRect.left;
                    const toY = toRect.top + toRect.height/2 - areaRect.top;
                    
                    const length = Math.sqrt(Math.pow(toX - fromX, 2) + Math.pow(toY - fromY, 2));
                    const angle = Math.atan2(toY - fromY, toX - fromX) * 180 / Math.PI;
                    
                    const channelElement = document.createElement('div');
                    channelElement.className = 'ipc-channel';
                    channelElement.style.width = `${length}px`;
                    channelElement.style.left = `${fromX}px`;
                    channelElement.style.top = `${fromY}px`;
                    channelElement.style.transform = `rotate(${angle}deg)`;
                    channelElement.style.backgroundColor = getChannelColor(channel.action);
                    visualizationArea.appendChild(channelElement);
                    
                    // Add arrowhead
                    const arrow = document.createElement('div');
                    arrow.style.position = 'absolute';
                    arrow.style.width = '0';
                    arrow.style.height = '0';
                    arrow.style.borderLeft = '6px solid transparent';
                    arrow.style.borderRight = '6px solid transparent';
                    arrow.style.borderTop = `10px solid ${getChannelColor(channel.action)}`;
                    arrow.style.left = `${toX - 6 - areaRect.left}px`;
                    arrow.style.top = `${toY - 10 - areaRect.top}px`;
                    arrow.style.transform = `rotate(${angle}deg)`;
                    visualizationArea.appendChild(arrow);
                    
                    // Add label
                    const label = document.createElement('div');
                    label.className = 'ipc-label';
                    label.textContent = getChannelLabel(channel.action, channel.resource);
                    label.style.left = `${(fromX + toX) / 2 - 30}px`;
                    label.style.top = `${(fromY + toY) / 2 - 10}px`;
                    visualizationArea.appendChild(label);
                }
            });
        }
        
        function getChannelColor(action) {
            switch(action) {
                case 'request': return '#ff9800';
                case 'transfer': return '#4caf50';
                case 'acquire': return '#2196f3';
                case 'release': return '#f44336';
                default: return '#ffffff';
            }
        }
        
        function getChannelLabel(action, resource) {
            switch(action) {
                case 'request': return `Request ${resource}`;
                case 'transfer': return `Transfer ${resource}`;
                case 'acquire': return `Acquire ${resource}`;
                case 'release': return `Release ${resource}`;
                default: return 'Communication';
            }
        }
        
        function checkDeadlock() {
            const detectionMethod = document.querySelector('input[name="detection-method"]:checked').value;
            let cycle = null;
            
            switch(detectionMethod) {
                case 'rag':
                    cycle = detectWithRAG();
                    break;
                case 'wait-for':
                    cycle = detectWithWaitFor();
                    break;
                case 'banker':
                    cycle = detectWithBanker();
                    break;
                case 'random':
                    if (Math.random() < 0.3) {
                        cycle = detectWithRAG() || detectWithWaitFor();
                    }
                    break;
            }
            
            if (cycle) {
                deadlockDetected = true;
                deadlockCount++;
                document.getElementById("resolve-deadlock").style.display = "inline-block";
                document.getElementById("deadlock-status").innerHTML = 
                    '<span style="color:#dc3545">DEADLOCK DETECTED!</span>';
                
                let reason = "Deadlock detected using " + 
                    (detectionMethod === 'rag' ? "Resource Allocation Graph" :
                     detectionMethod === 'wait-for' ? "Wait-For Graph" :
                     detectionMethod === 'banker' ? "Banker's Algorithm" : "Random Detection");
                
                reason += ": " + cycle.map((p, i) => 
                    `${p} is waiting for ${cycle[(i+1)%cycle.length]}'s resource`
                ).join(", ");
                
                document.getElementById("deadlock-reason").textContent = reason;
                logMessage(`Deadlock detected: ${reason}`);
                stopExchange();
                updateStatistics();
            } else {
                document.getElementById("deadlock-status").innerHTML = 
                    "No deadlock detected";
                document.getElementById("resolve-deadlock").style.display = "none";
                document.getElementById("deadlock-reason").textContent = "";
                deadlockDetected = false;
            }
        }
        
        function detectWithRAG() {
            const graph = {};
            const blockedProcesses = processes.filter(p => p.status === 'blocked');
            
            blockedProcesses.forEach(process => {
                const resource = resources.find(r => r.id === process.waiting);
                if (resource && resource.holder) {
                    if (!graph[process.id]) graph[process.id] = [];
                    graph[process.id].push(resource.holder);
                }
            });
            
            return findCycle(graph);
        }
        
        function detectWithWaitFor() {
            const graph = {};
            const blockedProcesses = processes.filter(p => p.status === 'blocked');
            
            blockedProcesses.forEach(process => {
                const resource = resources.find(r => r.id === process.waiting);
                if (resource && resource.holder) {
                    if (!graph[process.id]) graph[process.id] = [];
                    graph[process.id].push(resource.holder);
                }
            });
            
            return findCycle(graph);
        }
        
        function detectWithBanker() {
            // Simplified Banker's algorithm for deadlock detection
            const available = resources.filter(r => r.holder === null).length;
            const work = available;
            const finish = Array(processes.length).fill(false);
            
            // Find a process that can be satisfied with current resources
            let found;
            do {
                found = false;
                for (let i = 0; i < processes.length; i++) {
                    if (!finish[i] && (processes[i].needed - processes[i].holding.length) <= work) {
                        work += processes[i].holding.length;
                        finish[i] = true;
                        found = true;
                    }
                }
            } while (found);
            
            // If all processes couldn't finish, there's a deadlock
            if (!finish.every(f => f)) {
                const deadlockedProcesses = processes.filter((p, i) => !finish[i]).map(p => p.id);
                return deadlockedProcesses.length > 0 ? deadlockedProcesses : null;
            }
            
            return null;
        }
        
        function findCycle(graph) {
            const visited = {};
            const recursionStack = {};
            const cyclePath = [];
            
            function dfs(node) {
                if (!visited[node]) {
                    visited[node] = true;
                    recursionStack[node] = true;
                    cyclePath.push(node);
                    
                    const neighbors = graph[node] || [];
                    for (const neighbor of neighbors) {
                        if (!visited[neighbor] && dfs(neighbor)) {
                            return true;
                        } else if (recursionStack[neighbor]) {
                            const cycleStart = cyclePath.indexOf(neighbor);
                            if (cycleStart !== -1) {
                                window.cycle = cyclePath.slice(cycleStart);
                                return true;
                            }
                        }
                    }
                    
                    cyclePath.pop();
                    recursionStack[node] = false;
                }
                return false;
            }
            
            for (const node in graph) {
                if (dfs(node)) {
                    return window.cycle;
                }
            }
            return null;
        }
        
        function resolveDeadlock() {
            if (!deadlockDetected) return;
            
            const recoveryMethod = document.querySelector('input[name="recovery-method"]:checked').value;
            const cycle = window.cycle || processes.filter(p => p.status === 'blocked').map(p => p.id);
            
            if (cycle.length === 0) return;
            
            const victimId = cycle[Math.floor(Math.random() * cycle.length)];
            const victimIndex = processes.findIndex(p => p.id === victimId);
            
            if (victimIndex === -1) return;
            
            if (recoveryMethod === 'termination') {
                // Process termination
                processes[victimIndex].holding.forEach(resId => {
                    const resource = resources.find(r => r.id === resId);
                    if (resource) {
                        resource.holder = null;
                        resource.available++;
                    }
                });
                
                const terminatedProcess = processes.splice(victimIndex, 1)[0];
                logMessage(`Resolved deadlock by terminating ${victimId} (was holding: ${terminatedProcess.holding.join(', ') || 'none'})`);
            } else {
                // Resource preemption
                const victimProcess = processes[victimIndex];
                if (victimProcess.holding.length > 0) {
                    const resourceId = victimProcess.holding[0];
                    const resource = resources.find(r => r.id === resourceId);
                    
                    victimProcess.holding = victimProcess.holding.filter(id => id !== resourceId);
                    resource.holder = null;
                    resource.available++;
                    
                    logMessage(`Resolved deadlock by preempting ${resourceId} from ${victimId}`);
                    
                    // Check if any process was waiting for this resource
                    processes.forEach(p => {
                        if (p.waiting === resourceId) {
                            p.waiting = null;
                            p.status = 'running';
                            logMessage(`${p.id} no longer waiting for ${resourceId}`);
                        }
                    });
                }
            }
            
            updateProcessTable();
            updateResourceTable();
            updateVisualization();
            updateStatistics();
            
            deadlockDetected = false;
            document.getElementById("resolve-deadlock").style.display = "none";
            document.getElementById("deadlock-status").innerHTML = "Deadlock resolved";
            document.getElementById("deadlock-reason").textContent = "";
            
            calculateSafeSequence();
        }
        
        function calculateSafeSequence() {
            const available = resources.filter(r => r.holder === null).length;
            let work = available;
            const finish = Array(processes.length).fill(false);
            const safeSequence = [];
            
            let found;
            do {
                found = false;
                for (let i = 0; i < processes.length; i++) {
                    if (!finish[i] && (processes[i].needed - processes[i].holding.length) <= work) {
                        work += processes[i].holding.length;
                        finish[i] = true;
                        safeSequence.push(processes[i].id);
                        found = true;
                    }
                }
            } while (found);
            
            const allFinished = finish.every(f => f);
            const container = document.getElementById("safe-sequence-container");
            const sequenceDiv = document.getElementById("safe-sequence");
            
            if (allFinished && processes.length > 0) {
                sequenceDiv.innerHTML = safeSequence.map(proc => 
                    `<span class="sequence-step">${proc}</span>`
                ).join(' → ');
                container.style.display = "block";
                logMessage(`Safe execution sequence: ${safeSequence.join(" → ")}`);
            } else if (processes.length > 0) {
                sequenceDiv.innerHTML = "No safe sequence exists with current allocations";
                container.style.display = "block";
                logMessage("No safe sequence exists with current allocations");
            } else {
                container.style.display = "none";
            }
        }
        
        function updateProcessTable() {
            let table = `
                <table>
                    <tr>
                        <th>Process</th>
                        <th>Status</th>
                        <th>Holding</th>
                        <th>Waiting</th>
                        <th>Needs</th>
                        <th>Max</th>
                    </tr>`;
            
            processes.forEach(process => {
                const statusClass = process.status === 'running' ? 'status-running' : 'status-blocked';
                table += `
                    <tr>
                        <td>${process.id}</td>
                        <td><span class="status-indicator ${statusClass}"></span>${process.status}</td>
                        <td>${process.holding.join(', ') || '-'}</td>
                        <td>${process.waiting || '-'}</td>
                        <td>${process.needed}</td>
                        <td>${process.max}</td>
                    </tr>`;
            });
            
            table += `</table>`;
            document.getElementById("process-table").innerHTML = table;
        }
        
        function updateResourceTable() {
            let table = `
                <table>
                    <tr>
                        <th>Resource</th>
                        <th>Holder</th>
                        <th>Waiters</th>
                        <th>Available</th>
                    </tr>`;
            
            resources.forEach(resource => {
                const waiters = processes.filter(p => p.waiting === resource.id)
                                       .map(p => p.id)
                                       .join(', ') || '-';
                table += `
                    <tr>
                        <td>${resource.id}</td>
                        <td>${resource.holder || 'Free'}</td>
                        <td>${waiters}</td>
                        <td>${resource.available}/${resource.total}</td>
                    </tr>`;
            });
            
            document.getElementById("resource-table").innerHTML = table + `</table>`;
        }
        
        function updateStatistics() {
            document.getElementById("exchange-count").textContent = exchangeCount;
            document.getElementById("deadlock-count").textContent = deadlockCount;
            
            const blockedCount = processes.filter(p => p.status === 'blocked').length;
            document.getElementById("blocked-count").textContent = blockedCount;
            
            const usedResources = resources.filter(r => r.holder !== null).length;
            const resourceUsage = Math.round((usedResources / resources.length) * 100);
            document.getElementById("resource-usage").textContent = `${resourceUsage}%`;
        }
        
        function getIPCMethodVisualization() {
            const method = document.getElementById("ipc-method").value;
            switch(method) {
                case 'pipe':
                    return "↔ Pipe communication ↔";
                case 'queue':
                    return "⇄ Message queue ⇄";
                case 'shm':
                    return "⇶ Shared memory ⇶";
                default:
                    return "↔ Communicating ↔";
            }
        }
        
        function logMessage(message) {
            const logElement = document.getElementById("log-container");
            const entry = document.createElement("div");
            entry.className = "log-entry";
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logElement.appendChild(entry);
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        function logExchange(message) {
            const logElement = document.getElementById("exchange-log");
            const entry = document.createElement("div");
            entry.className = "log-entry";
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logElement.appendChild(entry);
            logElement.scrollTop = logElement.scrollHeight;
        }
        
        // Initialize
        setupSystem();
    </script>
</body>
</html>